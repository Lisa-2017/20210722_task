### 1. 请说出下列最终执行结果，并解释为什么?

```javascript
var a = [];
for(var i = 0; i < 10; i++) {
  a[i] = function() {
    console.log(i)
  }
}
a[6]()
```
#### 解答1
 执行结果为10 
#### 解析：
> for循环中的i使用了 var 声明，
此时i经过变量提升，变成了全局作用域中的变量，
而for循环中不存在块级作用域概念，所以for循环结束后 i的 最终被赋值为10 
a[i]的函数体内部使用的i 此时就是全局作用域中的i 也就是10
所以 当调用的`a[x]() `无论x为(1-10)中的任意数字时 结果都是10


### 2. 请说出此案列最终执行结果，并解释为什么?

```javascript
var tmp = 123;
if (true) {
  console.log(tmp);
  let tmp;
}
```
#### 解答
应该报错
#### 解析
> 虽然在全局中已经定义并复制给了tmp
依据变量的查找规则，先从自身所在的作用域中查找，如果找不到才向父级作用域查找
显然在代码预解析的时候，已经知道了if代码块中有声明变量tmp
但是由于let关键字声明的变量不会被提升，且let tmp 在console.log下方定义
因此在运行代码时，当执行console.log时找不到tmp 就会报引用错误


### 3. 结合ES6语法，用最简单的方式找出数组中的最小值

```javascript
var arr = [12, 34, 32, 89, 4]
```
#### 解答
Math.min(...arr)

### 4. 请详细说明var、let、const三种声明变量的方式之间的具体差别
#### var
> * 语法:  var a= 1
> * 作用域： 全局作用域 || 函数作用域
> * 访问顺序：可以先访问后声明
> * 变量提升:变量会提升到当前作用域的顶部，并赋值为undefined，代码运行到当前行时才会被赋值为1
> * 初始化:可以仅声明不赋初始值
> * 重复定义:可以被重复定义，先定义的会被后定义的覆盖
> * 多次赋值: 可以

#### let
> * 语法:  let a= 1
> * 作用域： 块级作用域
> * 访问顺序：必须先声明后访问
> * 变量提升: 不提升
> * 初始化: 可以先声明不赋初始值
> * 重复定义:不可以
> * 多次赋值: 不可以

#### const
> * 语法:  const a= 1
> * 作用域： 块级作用域
> * 访问顺序：必须先声明后访问
> * 变量提升: 不提升
> * 初始化: 声明的同时必须赋值初始化
> * 重复定义:不可以
> * 多次赋值: 不可以


### 5. 请说出下列代码最终输出结果，并解释为什么？

```javascript
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}
obj.fn()
```
#### 解答
20
#### 解析
> 在调用obj.fn() 时，this指向obj对象
又因为箭头函数没有自己的this,箭头函数的this指向声明时所在的作用域，
因此this为obj 所以 this.a === obj.a


### 6. 简述Symbol类型的用途
#### 解答（其实不是很熟）
1.原始值且实例是唯一不可变的 
2.可作为私有属性 
3.内置符号 
4.全局符号注册表 
5.支持可迭代

### 7. 说说什么是浅拷贝，什么是深拷贝？
#### 解答
>* 浅拷贝：对于基本类型，直接复制了一份；对于引用类型，拷贝了引用地址，改变原属性会影响新属性；
> * 深拷贝：直开辟一片新空间，直接复制全部内容（包含子对象），改变原属性不会影响新属性。


### 9. 请谈谈你所认为的typescript优缺点
#### 解答
> * 优点：
支持原生JS
内置类型系统
支持新特性（替代babel），可以编制到ES3
任何一种JS运行环境都支持
功能更强大，生态更健全，更完善（尤其是开发工具更流畅）
TS属于 【渐进式】，可以边学边用
对于大型项目，一劳永逸
> * 缺点：
需要额外学习一些概念。
对于周期比较短的小型项目，项目初期，TS会因为编写开发声明增加一些开发量
　

### 10. 描述引用计数的工作原理和优缺点
>* 原理： 
设置引用数， 判断当前引用数是否为0
引用关系改变时修改引用数字
引用数字为0 时立即回收
>* 优点：
发现垃圾立即回收
最大限度减少程序暂停
>* 缺点:
无法回收循环引用的对象
时间开销大


### 11. 描述标记整理算法的工作流程
>标记阶段 遍历所有对象，对活动对象做标记
清除阶段 会先执行整理，移动对象位置
统一回收
　

### 12.描述V8中新生代存储区垃圾回收的流程
>回收过程采用复制算法 + 标记整理
新生代内存区 分为2个等大的空间
使用空间为From, 空闲空间为To
活动对象存储于From空间
标记整理后 将 活动对象 copy至 To空间
From与To交换空间 完成释放
>* 可能会触发晋升
>   经过一轮GC之后，还存活的新生代需要晋升
>   在copy过程中，To空间的使用率超过25%时会出现晋升
　

### 13. 描述增量标记算法在何时使用及工作原理
>* 使用情景：
  程序遇到大块需要标记的对象时，程序会暂停很长一段时间
  用户体验应用程序卡顿
>* 工作原理：增量标记 将当前一整段的垃圾回收操作，拆分成多个小段，组合着完成整个垃圾回收，从而替代之前一次性做完的垃圾回收操作。最后标记完成后统一进行回收。优化了用户体验


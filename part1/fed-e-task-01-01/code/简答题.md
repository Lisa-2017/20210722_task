## 简答题

#### 谈谈你是如何理解 JS 异步编程的，EventLoop、消息队列都是做什么的，什么是宏任务，什么是微任务？

**答:**

- JS是单线程的：
    - JS最初的设计主要的功能是对浏览器的Dom做操作实现页面上的动态交互, 为了避免出现很复杂的线程同步问题，JS就设计成了单线程的工作模式。
    - 因此JS环境中负责执行代码的线程只有一个
    - 那么在一堆同步任务队列下,面对一些特别耗时的任务时,会发生阻塞,其他的任务就要等待很长的时间, 甚至出现假死的情况。
    - 为了解决这种问题,便有了异步编程模式。

- JS 异步编程 ：
    - 当js线程开启了一个任务（发起了一个异步调用）后, 就立即向后继续执行其他的任务, 此时异步线程会单独执行异步任务，执行过后会将回调放回到消息队列中,js主线程执行完任务后会一次执行消息队列中的任务。

    - JS异步编程的首要任务就是用来提高JS单线程执行机制下的处理效率的, 针对一些耗时操作及宿主环境下的api交互, 例如:接口的请求调用, 文件的读写操作, 消息发送及接收, 通过异步编程的方式都能得到很好的提升。
    - 常用的JS异步编程的处理方式有回调函数、事件、Promise、Generator、Async Await。

####
- 消息队列
消息队列是暂时存放异步任务的地方，等同步代码执行完毕以后，EventLoop会从消息队列中依次取出异步任务放到调用栈再次执行

#### 
- EventLoop
从消息队列中读取事件，是个循环不断的过程，这种整个运行机制称为EventLoop(事件循环)
1、js引擎线程会维护一个执行栈，同步代码依次加入到执行栈中，执行完后移出执行栈
2、js引擎线程如果遇到异步函数，会将异步函数交给相应的Webapi，然后去继续执行后面的任务
3、Webapi会在满足条件的时候，将异步对应的回调加入到消息队列中，等待执行
4、当执行栈为空时，js引擎会去读取消息队列中的回调函数，如果有会再次加入到执行栈中去执行
5、完成后出栈，执行栈再次为空，循环上面的操作

#### 
- 宏任务：消息队列中的任务 例如：SetTimeout，SetInterval 等

#### 
- 微任务：基于当前任务产生随着当前任务结束后立即执行的任务，所以也是异步任务，不需要通过EventLoop监测，通过消息队列取出并压入执行栈中再执行 例如：Promise

#### JS引擎执行一段代码，一般经过以下几个步骤
   ```
    1、先读取js代码
    2、将代码压入执行栈
    3、处理执行的各段代码
    4、如果是同步任务，处理结束了，移出执行栈
    5、如果是异步任务，执行栈处理完了 会委托宿主环境去执行任务，执行完后，再把这个任务的执行结果通过回调函数注册到消息队列中
    6、执行栈的任务都执行完后，js会通过EventLoop事件去监听消息队列，将消息队列的任务按照顺序压入执行栈进行执行

